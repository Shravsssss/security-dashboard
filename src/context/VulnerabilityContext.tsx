import React, { createContext, useContext, ReactNode } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useState, useMemo } from 'react';
import { VulnerabilityData, VulnerabilityMetrics, FilterState } from '../types/vulnerability.types';
import { loadVulnerabilityData } from '../utils/dataLoader';
import { processVulnerabilityData, filterVulnerabilities } from '../utils/dataProcessing';

interface VulnerabilityContextType {
  data: VulnerabilityData[];
  filteredData: VulnerabilityData[];
  metrics: VulnerabilityMetrics | undefined;
  filters: FilterState;
  availableSeverities: string[];
  isLoading: boolean;
  isFiltering: boolean;
  error: Error | null;
  isError: boolean;
  applyFilter: (filterType: keyof FilterState, value: any) => void;
  setFilters: React.Dispatch<React.SetStateAction<FilterState>>;
  resetFilters: () => void;
  // Tab state for conditional metrics calculation
  selectedTab: number;
  setSelectedTab: (tab: number) => void;
}

const VulnerabilityContext = createContext<VulnerabilityContextType | undefined>(undefined);

interface VulnerabilityProviderProps {
  children: ReactNode;
}

/**
 * Vulnerability Context Provider
 * Centralizes vulnerability data and filter state management
 * Ensures all components share the same data and filter state
 */
export const VulnerabilityProvider: React.FC<VulnerabilityProviderProps> = ({ children }) => {
  const queryClient = useQueryClient();
  const [filters, setFilters] = useState<FilterState>({
    excludeNoRisk: false,
    excludeAiNoRisk: false,
    searchTerm: '',
    selectedSeverities: [],
  });
  const [availableSeverities, setAvailableSeverities] = useState<string[]>([]);

  // Tab state - used to defer expensive metrics calculation
  const [selectedTab, setSelectedTab] = useState(0);

  // Filtering state for showing loading indicator
  const [isFiltering, setIsFiltering] = useState(false);

  // Fetch vulnerability data with React Query
  const { data: rawData, isLoading, error, isError } = useQuery({
    queryKey: ['vulnerabilities'],
    queryFn: async () => {
      const data = await loadVulnerabilityData();

      // Calculate metrics synchronously to ensure they're available immediately
      const metrics = processVulnerabilityData(data);
      queryClient.setQueryData(['metrics'], metrics);

      // Extract unique severities synchronously
      const severitiesSet = new Set<string>();

      data.forEach((item) => {
        if (item.severity) {
          severitiesSet.add(item.severity);
        }
      });

      setAvailableSeverities(Array.from(severitiesSet).sort());

      return data;
    },
    staleTime: Infinity,
    gcTime: Infinity,
  });

  // Get cached metrics (from raw data) - always show total metrics
  const metrics = queryClient.getQueryData<VulnerabilityMetrics>(['metrics']);

  // Load ALL data at once - no chunking/pagination, only virtualization
  const data = useMemo(() => {
    if (!rawData) return [];
    return rawData;
  }, [rawData]);

  // Apply filters with loading indicator for large datasets
  const filteredData = useMemo(() => {
    if (!data || data.length === 0) {
      setIsFiltering(false);
      return [];
    }

    // Show filtering indicator for large datasets
    if (data.length > 10000) {
      setIsFiltering(true);
    }

    const excludeKaiStatus: string[] = [];
    if (filters.excludeNoRisk) excludeKaiStatus.push('invalid - norisk');
    if (filters.excludeAiNoRisk) excludeKaiStatus.push('ai-invalid-norisk');

    const result = filterVulnerabilities(data, {
      searchTerm: filters.searchTerm,
      severities: filters.selectedSeverities,
      excludeKaiStatus,
    });

    // Hide filtering indicator after a brief delay to show the change
    setTimeout(() => setIsFiltering(false), 100);

    return result;
  }, [data, filters]);

  // Apply individual filter
  const applyFilter = (filterType: keyof FilterState, value: any) => {
    setFilters((prev) => ({
      ...prev,
      [filterType]: value,
    }));
  };

  // Reset all filters
  const resetFilters = () => {
    setFilters({
      excludeNoRisk: false,
      excludeAiNoRisk: false,
      searchTerm: '',
      selectedSeverities: [],
    });
  };

  const value: VulnerabilityContextType = {
    data: data || [],
    filteredData,
    metrics,
    filters,
    availableSeverities,
    isLoading,
    isFiltering,
    error: error as Error | null,
    isError,
    applyFilter,
    setFilters,
    resetFilters,
    selectedTab,
    setSelectedTab,
  };

  return (
    <VulnerabilityContext.Provider value={value}>
      {children}
    </VulnerabilityContext.Provider>
  );
};

/**
 * Hook to use vulnerability context
 * Must be used within VulnerabilityProvider
 */
export const useVulnerabilityContext = () => {
  const context = useContext(VulnerabilityContext);
  if (context === undefined) {
    throw new Error('useVulnerabilityContext must be used within VulnerabilityProvider');
  }
  return context;
};
