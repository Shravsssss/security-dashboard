import React, { useMemo, useState, useEffect, useRef } from 'react';
import { List, RowComponentProps } from 'react-window';
import {
  Box,
  Paper,
  Typography,
  Chip,
  styled,
  IconButton,
  CircularProgress,
  Backdrop,
} from '@mui/material';
import {
  ArrowUpward,
  ArrowDownward,
  UnfoldMore,
  CompareArrows,
  CheckCircle,
} from '@mui/icons-material';
import { VulnerabilityData } from '../../types/vulnerability.types';
import { getSeverityColorName } from '../../utils/severityUtils';
import { getCvssColor } from '../../utils/cvssUtils';
import { useSortWorker } from '../../hooks/useSortWorker';

interface VirtualizedTableProps {
  data: VulnerabilityData[];
  onRowClick?: (item: VulnerabilityData) => void;
  onAddToComparison?: (item: VulnerabilityData) => void;
  comparisonList?: VulnerabilityData[];
}

interface ItemData {
  items: VulnerabilityData[];
  onRowClick?: (item: VulnerabilityData) => void;
  onAddToComparison?: (item: VulnerabilityData) => void;
  comparisonList?: VulnerabilityData[];
}

const StyledTableHeader = styled(Box)(({ theme }) => ({
  display: 'grid',
  gridTemplateColumns: '1.5fr 0.8fr 0.8fr 1.2fr 1.2fr 1fr 1fr 1.5fr 0.8fr 80px',
  padding: '12px 16px',
  backgroundColor: theme.palette.primary.main,
  color: theme.palette.primary.contrastText,
  fontWeight: 'bold',
  borderRadius: '4px 4px 0 0',
}));

const SortableHeader = styled(Box)(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  gap: '4px',
  cursor: 'pointer',
  userSelect: 'none',
  '&:hover': {
    opacity: 0.8,
  },
}));

const StyledRow = styled(Box, {
  shouldForwardProp: (prop) => prop !== 'isEven',
})<{ isEven: boolean }>(({ theme, isEven}) => ({
  display: 'grid',
  gridTemplateColumns: '1.5fr 0.8fr 0.8fr 1.2fr 1.2fr 1fr 1fr 1.5fr 0.8fr 80px',
  padding: '12px 16px',
  borderBottom: `1px solid ${theme.palette.divider}`,
  backgroundColor: isEven ? theme.palette.action.hover : 'transparent',
  transition: 'background-color 0.2s',
  '&:hover': {
    backgroundColor: theme.palette.action.selected,
  },
}));

// Row component for rendering each vulnerability
// Note: react-window v2.x handles memoization internally
const Row = ({
  index,
  style,
  ariaAttributes,
  items,
  onRowClick,
  onAddToComparison,
  comparisonList,
}: RowComponentProps<ItemData>) => {
  const item = items[index];
  const isInComparison = comparisonList?.some((v: VulnerabilityData) => v.id === item.id) || false;

  const handleCompareClick = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent row click
    onAddToComparison?.(item);
  };

  const handleRowClick = () => {
    onRowClick?.(item);
  };

  return (
    <StyledRow
      style={style}
      isEven={index % 2 === 0}
      onClick={handleRowClick}
      {...ariaAttributes}
    >
      <Typography
        variant="body2"
        sx={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}
      >
        {item.package}
      </Typography>
      <Box>
        <Chip label={item.severity} color={getSeverityColorName(item.severity)} size="small" />
      </Box>
      <Typography
        variant="body2"
        sx={{
          fontWeight: 600,
          color: getCvssColor(item.cvss),
        }}
      >
        {item.cvss !== undefined && item.cvss !== null ? item.cvss.toFixed(1) : 'N/A'}
      </Typography>
      <Typography
        variant="body2"
        sx={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}
      >
        {item.cve || 'N/A'}
      </Typography>
      <Typography
        variant="body2"
        sx={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}
      >
        {item.status || 'N/A'}
      </Typography>
      <Typography variant="body2">{item.version || 'N/A'}</Typography>
      <Typography variant="body2" sx={{ fontSize: '0.75rem' }}>
        {item.timestamp ? new Date(item.timestamp).toLocaleDateString() : 'N/A'}
      </Typography>
      <Typography
        variant="body2"
        sx={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}
      >
        {item.kaiStatus}
      </Typography>
      <Typography variant="body2">
        {item.riskFactors?.length || 0}
      </Typography>
      <Box display="flex" alignItems="center" justifyContent="center">
        {onAddToComparison && (
          <IconButton
            size="small"
            onClick={handleCompareClick}
            disabled={isInComparison}
            color={isInComparison ? 'success' : 'primary'}
            title={isInComparison ? 'Already in comparison' : 'Add to comparison'}
          >
            {isInComparison ? <CheckCircle fontSize="small" /> : <CompareArrows fontSize="small" />}
          </IconButton>
        )}
      </Box>
    </StyledRow>
  );
};

type SortField = keyof VulnerabilityData | 'riskFactorsCount';

/**
 * Virtualized table component using react-window for handling large datasets
 * Efficiently renders only visible rows for performance
 */
export const VirtualizedTable: React.FC<VirtualizedTableProps> = ({
  data,
  onRowClick,
  onAddToComparison,
  comparisonList,
}) => {
  // Track window height for responsive table sizing
  const [windowHeight, setWindowHeight] = useState(window.innerHeight);

  // Sorting state
  const [sortField, setSortField] = useState<SortField | null>(null);
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
  const [sortedData, setSortedData] = useState<VulnerabilityData[]>(data);
  const [isSorting, setIsSorting] = useState(false);
  const sortingRef = useRef(false);

  // Initialize sort worker for async sorting
  const { sortData } = useSortWorker();

  // Add resize listener to update table height when window is resized
  useEffect(() => {
    const handleResize = () => {
      setWindowHeight(window.innerHeight);
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Calculate the height for the list (max 600px or window height - 300px)
  const listHeight = useMemo(() => {
    return Math.min(600, windowHeight - 300);
  }, [windowHeight]);

  // Perform sort when data, sortField, or sortDirection changes - using Web Worker
  useEffect(() => {
    // Guard: Don't sort if data is empty or invalid
    if (!data || data.length === 0) {
      setSortedData([]);
      setIsSorting(false);
      sortingRef.current = false;
      return;
    }

    if (!sortField) {
      setSortedData(data);
      setIsSorting(false);
      sortingRef.current = false;
      return;
    }

    // Guard: Prevent concurrent sort operations
    if (sortingRef.current) {
      return;
    }

    sortingRef.current = true;
    setIsSorting(true);

    // Perform sorting in Web Worker (non-blocking)
    sortData({
      data,
      field: sortField,
      direction: sortDirection,
    })
      .then((result) => {
        if (result.error) {
          console.error('Sort error:', result.error);
          // Fallback to original data if sorting fails
          setSortedData(data);
        } else {
          setSortedData(result.data);
        }
      })
      .catch((error) => {
        console.error('Sort worker error:', error);
        // Fallback to original data
        setSortedData(data);
      })
      .finally(() => {
        setIsSorting(false);
        sortingRef.current = false;
      });

    // Cleanup: Reset sorting flag if effect re-runs
    return () => {
      sortingRef.current = false;
    };
  }, [data, sortField, sortDirection, sortData]);

  // Handle column header click for sorting
  const handleSort = (field: SortField) => {
    if (sortField === field) {
      // Toggle direction if clicking the same field
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      // New field, default to descending for severity/cvss, ascending for others
      setSortField(field);
      setSortDirection(field === 'severity' || field === 'cvss' ? 'desc' : 'asc');
    }
  };

  // Render sort icon based on current state
  const renderSortIcon = (field: SortField) => {
    if (sortField !== field) {
      return <UnfoldMore fontSize="small" />;
    }
    return sortDirection === 'asc' ? (
      <ArrowUpward fontSize="small" />
    ) : (
      <ArrowDownward fontSize="small" />
    );
  };

  // Memoize rowProps to prevent unnecessary re-renders
  const rowProps = useMemo(
    () => ({
      items: sortedData,
      onRowClick,
      onAddToComparison,
      comparisonList,
    }),
    [sortedData, onRowClick, onAddToComparison, comparisonList]
  );

  return (
    <Paper elevation={3} sx={{ width: '100%', overflow: 'hidden' }}>
      {/* Header */}
      <StyledTableHeader>
        <SortableHeader onClick={() => handleSort('package')}>
          <Typography variant="subtitle2" fontWeight="bold">
            Package
          </Typography>
          {renderSortIcon('package')}
        </SortableHeader>
        <SortableHeader onClick={() => handleSort('severity')}>
          <Typography variant="subtitle2" fontWeight="bold">
            Severity
          </Typography>
          {renderSortIcon('severity')}
        </SortableHeader>
        <SortableHeader onClick={() => handleSort('cvss')}>
          <Typography variant="subtitle2" fontWeight="bold">
            CVSS
          </Typography>
          {renderSortIcon('cvss')}
        </SortableHeader>
        <Box display="flex" alignItems="center" paddingX={1}>
          <Typography variant="subtitle2" fontWeight="bold">
            CVE
          </Typography>
        </Box>
        <Box display="flex" alignItems="center" paddingX={1}>
          <Typography variant="subtitle2" fontWeight="bold">
            Status
          </Typography>
        </Box>
        <SortableHeader onClick={() => handleSort('version')}>
          <Typography variant="subtitle2" fontWeight="bold">
            Version
          </Typography>
          {renderSortIcon('version')}
        </SortableHeader>
        <Box display="flex" alignItems="center" paddingX={1}>
          <Typography variant="subtitle2" fontWeight="bold">
            Published
          </Typography>
        </Box>
        <SortableHeader onClick={() => handleSort('kaiStatus')}>
          <Typography variant="subtitle2" fontWeight="bold">
            KAI Status
          </Typography>
          {renderSortIcon('kaiStatus')}
        </SortableHeader>
        <SortableHeader onClick={() => handleSort('riskFactorsCount')}>
          <Typography variant="subtitle2" fontWeight="bold">
            Risks
          </Typography>
          {renderSortIcon('riskFactorsCount')}
        </SortableHeader>
        <Box display="flex" alignItems="center" justifyContent="center">
          <Typography variant="subtitle2" fontWeight="bold">
            Actions
          </Typography>
        </Box>
      </StyledTableHeader>

      {/* Virtualized List */}
      {sortedData.length > 0 ? (
        <List
          style={{ height: listHeight, width: '100%' }}
          rowComponent={Row}
          rowCount={sortedData.length}
          rowHeight={56}
          rowProps={rowProps}
          overscanCount={5}
        />
      ) : (
        <Box p={4} textAlign="center">
          <Typography variant="body1" color="text.secondary">
            No vulnerabilities found
          </Typography>
        </Box>
      )}

      {/* Loading overlay during sort */}
      <Backdrop
        open={isSorting}
        sx={{
          position: 'absolute',
          zIndex: (theme) => theme.zIndex.drawer + 1,
          backgroundColor: 'rgba(255, 255, 255, 0.7)',
        }}
      >
        <Box display="flex" flexDirection="column" alignItems="center" gap={2}>
          <CircularProgress size={40} />
          <Typography variant="body2" color="primary">
            Sorting {data.length.toLocaleString()} records...
          </Typography>
        </Box>
      </Backdrop>
    </Paper>
  );
};

export default VirtualizedTable;
